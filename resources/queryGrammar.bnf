{
  generate = [names = "long" visitor-value = "R"]
  psiPackage = "generated"
  psiImplPackage = "generated"
  psiClassPrefix = ""
  psiImplClassSuffix = "Impl"
  elementTypeClass="com.simple1c.boilerplate._1cElementType"
  extends(".*Literal") = expression
  extends("identifier") = expression
  extends(".*expr") = expression

  tokens = [
    space='regexp:\s+'
    number='regexp:\d+'
    idSimple="regexp:[a-zA-Zа-яА-Я][a-zA-Zа-яА-Я0123456789]*"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
    line_comment="regexp://.*"
    WILDCARD = '*'
    DOT = '.'
    COMMA = ','
    LPAREN = '('
    RPAREN = ')'
    SEMICOLON = ';'
    EQ = '='
  ]
}

grammar ::= sqlQuery ((SEMICOLON) sqlQuery) ?

select_statement ::= !<<eof>> select topOpt distinctOpt selectList
fromKeyword tableDeclaration
joinItem*
[whereKeyword expression]
[groupByKeyword expressionList [havingKeyword expression]]{
    methods = [
        topCount = "topOpt/numberLiteral"
        topOpt = ""
        whereExpression = "expression[0]"
        havingExpression ="expression[1]"
        grouping = "expressionList"
        expressionList =""
        //todo. isDistinct
    ]
}

private fromKeyword ::= (from | из)
topOpt ::= [top numberLiteral] //TODO. trash.make private
private distinctOpt ::= distinct?
alias ::= as? identifier //TODO. trash.make private

//selection
selectionItem ::= expression alias? {
    methods = [
        identifier = ""
        alias = "alias/identifier"
    ]
}
selectionList ::= selectionItem (COMMA selectionItem)*{
    //TODO. isSelectAll
}

private selectList ::= (WILDCARD | selectionList ) {recoverWhile=notFromKeyword pin=1}
private notFromKeyword ::= !fromKeyword

//source
tableDeclaration ::= identifier alias?{
    methods = [
        alias = "alias/identifier"
        identifier = ""
        tableName = "identifier"
    ]
}
subquery ::= LPAREN sqlQuery RPAREN
subqueryTable::= subquery alias{
    methods = [
        subquery = "/subquery"
        alias = "alias/identifier"
    ]
}
columnSource::= tableDeclaration | subqueryTable

//optional clauses
private whereKeyword::= where | где
private groupByKeyword ::= (group by) | (сгруппировать по)
private havingKeyword ::= having | имеющие

//order by
private orderByKeyword::= (order by) | (упорядочить по)
private ascKeyword ::= asc | возр
private descKeyword::= desc | убыв
private orderDirectionOpt ::= [ascKeyword | descKeyword]
orderItem ::= expression orderDirectionOpt
private orderByExpressionList ::= orderItem (COMMA orderItem) *

//union
private unionKeyword ::= union| объединить
private allModifierOpt ::= [all | все]
private unionList ::= select_statement (unionKeyword allModifierOpt select_statement)*
sqlQuery::= unionList [orderByKeyword orderByExpressionList]

//join
private joinKeyword ::= join | соединение
private outerKeywordOpt ::= (outer | внешнее)?
private outerJoinKind::= full | left | right | полное | левое | правое
joinKind::= (inner | внутреннее) | (outerJoinKind outerKeywordOpt)

joinItem ::= joinKind? joinKeyword columnSource (on | по) expression

//identifiers
identifier ::= idSimple (DOT idSimple)*

stringLiteral ::= string
numberLiteral ::= number
boolLiteral ::= (true | false | истина | ложь)

expressionList ::=  expression (COMMA expression)*

expression ::=
//Priority increases from top to bottom
//  expression 'or' expression
//  | expression 'and' expression
//  | 'not' expression
  comparison_group
  | add_group
  | mul_group
  | primary_group

private mul_group ::= expression '*' expression | expression '/' expression | expression '%' expression
private add_group ::= expression '+' expression | expression '-' expression
private comparison_group ::= expression EQ expression
    | expression ('<>' | '!=') expression
    | expression ('<') expression
    | expression ('<=') expression
    | expression ('>') expression
    | expression ('>=') expression
    | expression ('like' | 'подобно') expression
private primary_group ::=
    identifier
    | numberLiteral
    | boolLiteral
    | stringLiteral
    | '(' expression ')'
