{
  generate = [names = "long" visitor-value = "R"]
  psiPackage = "generated"
  psiImplPackage = "generated"
  psiClassPrefix = ""
  psiImplClassSuffix = "Impl"
  elementTypeClass="com.simple1c.boilerplate._1cElementType"
  extends(".*Literal") = expression
  extends("identifier") = expression
  extends(".*Expr") = expression
  extends(".*Expression") = expression
  extends("tableDeclaration") = columnSource
  extends("subqueryTable") = columnSource

  tokens = [
    ASTERISK = '*'
    DOT = '.'
    COMMA = ','
    LPAREN = '('
    RPAREN = ')'
    SEMICOLON = ';'
    OP_EQ = '='
    OP_DIV = '/'
    OP_REM = '%'
    OP_PLUS = '+'
    OP_MINUS = '-'
    OP_NEQ = 'regexp:<>|\!\='
    OP_LT = '<'
    OP_LTE = '<='
    OP_GT = '>'
    OP_GTE = '>='
    OP_LIKE = 'regexp:like|подобно'
    OP_NOT = 'regexp:not|не'
    OP_AND = 'regexp:and|и'
    OP_OR = 'regexp:or|или'
    //pretending these words are reserved (they're not)
    //if anyone calls a column 'различные', we're screwed
    selectKeyword = 'regexp:select|выбрать'
    whereKeyword = 'regexp:where|где'
    fromKeyword = 'regexp:from|из'
    topKeyword = 'regexp:top|первые'
    distinctKeyword = 'regexp:distinct|различные'
    asKeyword = 'regexp:as|как'
    groupKeyword = 'regexp:group|сгруппировать'
    orderKeyword = 'regexp:order|упорядочить'
    ascKeyword = 'regexp:asc|возр'
    descKeyword = 'regexp:desc|убыв'
    havingKeyword = 'regexp:having|имеющие'
    unionKeyword = 'regexp:union|объединить'
    allKeyword = 'regexp:all|все'
    joinKeyword = 'regexp:join|соединение'
    outerKeyword = 'regexp:outer|внешнее'
    fullKeyword = 'regexp:full|полное'
    leftKeyword = 'regexp:left|левое'
    rightKeyword = 'regexp:right|правое'
    innerKeyword = 'regexp:inner|внутреннее'
    byKeyword = 'by'
    onKeyword = 'on'
    поKeyword = 'по'
    WHITE_SPACE = 'regexp:[\s]+'
    number = 'regexp:\d+'
    bool = 'regexp:true|false|истина|ложь'
    ID_TOKEN = 'regexp:([a-zA-Zа-яА-Я][a-zA-Zа-яА-Я0123456789]*)(\.([a-zA-Zа-яА-Я][a-zA-Zа-яА-Я0123456789]*))*'
    string = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
    line_comment = 'regexp://.*'
  ]
}

grammar ::= (querySeparator? sqlQuery)*

private querySeparator ::= SEMICOLON

select_statement ::= !<<eof>> selectKeyword topOpt distinctOpt selectList
fromKeyword columnSource
joinItem*
[whereKeyword expression]
[groupKeyword (byKeyword| поKeyword) expressionList [havingKeyword expression]]{
    pin = 1
    recoverWhile = notSeparator
    methods = [
        topCount = "topOpt/numberLiteral"
        topOpt = ""
        whereExpression = "expression[0]"
        havingExpression ="expression[1]"
        grouping = "expressionList"
        expressionList =""
        //todo. isDistinct
    ]
}
private notSeparator ::= !(querySeparator)

topOpt ::= [topKeyword numberLiteral] //TODO. trash.make private
private distinctOpt ::= distinctKeyword?
alias ::= asKeyword? identifier{ //TODO. trash.make private
    methods = [
        asKeyword=""
    ]
}
//selection
selectionItem ::= expression alias? {
    methods = [
        identifier = ""
        alias = "alias/identifier"
    ]
}
selectionList ::= selectionItem (COMMA selectionItem)*{
    //TODO. isSelectAll
}

private selectList ::= (ASTERISK | selectionList ) {recoverWhile=notFromKeyword pin=1}
private notFromKeyword ::= !fromKeyword

//source
tableDeclaration ::= identifier alias?{
    methods = [
        alias = "alias/identifier"
        identifier = ""
        tableName = "identifier"
    ]
}
subquery ::= LPAREN sqlQuery RPAREN
subqueryTable::= subquery alias{
    methods = [
        subquery = "/subquery"
        alias = "alias/identifier"
    ]
}
columnSource::= tableDeclaration | subqueryTable

//order by
orderItem ::= expression [ascKeyword | descKeyword]
private orderByExpressionList ::= orderItem (COMMA orderItem) *

//union
private unionList ::= select_statement (unionKeyword allKeyword? select_statement)*
sqlQuery::= unionList [orderKeyword (byKeyword| поKeyword) orderByExpressionList]

//join
joinItem ::= joinKind? joinKeyword columnSource (onKeyword | поKeyword) expression {
//    recoverWhile = notAfterJoinKeyword
}
private notAfterJoinKeyword ::= !(groupKeyword | orderKeyword
| whereKeyword | unionKeyword | havingKeyword | selectKeyword)
joinKind::= innerKeyword | ((fullKeyword | leftKeyword| rightKeyword) (outerKeyword)?)

stringLiteral ::= string
numberLiteral ::= number
boolLiteral ::= bool

expressionList ::=  expression (COMMA expression)*

expression ::=
//Priority increases from top to bottom
  boolean_group
  | unary_group
  | comparison_group
  | add_group
  | mul_group
  | primary_group

fake binaryExpression::= expression expression {
    methods = [
        left = "expression[0]"
        right = "expression[1]"
        expressionList = ""
    ]
}
fake unaryExpression ::= expression {
    methods = [
        operand = "expression"
        expressionList = ""
    ]
}

private add_group ::=  addExpr| subtractExpr
addExpr ::= expression '+' expression {elementType = binaryExpression}
subtractExpr ::= expression '-' expression {elementType = binaryExpression}

private mul_group ::= multExpr | divExpr | remExpr
multExpr ::= expression ASTERISK expression {elementType = binaryExpression}
divExpr ::= expression OP_DIV expression {elementType = binaryExpression}
remExpr ::= expression OP_REM expression {elementType = binaryExpression}

private unary_group ::= unaryNotExpr
unaryNotExpr ::= OP_NOT expression {elementType = unaryExpression}

private comparison_group ::= eqExpr
    | neqExpr
    | ltExpr
    | lteExpr
    | gtExpr
    | gteExpr
    | likeExpr

eqExpr ::= expression OP_EQ expression {elementType = binaryExpression}
neqExpr ::= expression OP_NEQ expression {elementType = binaryExpression}
ltExpr ::= expression OP_LT expression {elementType = binaryExpression}
lteExpr ::= expression OP_LTE expression {elementType = binaryExpression}
gtExpr ::= expression OP_GT expression {elementType = binaryExpression}
gteExpr ::= expression OP_GTE expression {elementType = binaryExpression}
likeExpr ::= expression OP_LIKE expression {elementType = binaryExpression}

private boolean_group ::= andExpr | orExpr
andExpr ::= expression OP_AND expression {elementType = binaryExpression}
orExpr ::= expression OP_OR expression {elementType = binaryExpression}

private primary_group ::=
    identifier
    | numberLiteral
    | boolLiteral
    | stringLiteral
    | parExpr
identifier ::= ID_TOKEN
parExpr::= '(' expression ')' {elementType = expression}


