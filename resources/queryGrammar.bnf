{
//todo. ignore case.
  generate = [names = "long" visitor-value = "R"]
  psiPackage = "generated"
  psiImplPackage = "generated"
  psiClassPrefix = ""
  psiImplClassSuffix = "Impl"
  elementTypeClass="com.simple1c.boilerplate._1cElementType"
  extends(".*Literal") = expression
  extends("identifier") = expression
  extends(".*Expr") = expression
  extends(".*Expression") = expression

  tokens = [
    ASTERISK = '*'
    DOT = '.'
    COMMA = ','
    LPAREN = '('
    RPAREN = ')'
    SEMICOLON = ';'
    OP_EQ = '='
    OP_DIV = '/'
    OP_REM = '%'
    OP_PLUS = '+'
    OP_MINUS = '-'
    OP_NEQ = 'regexp:((<>)|(\!\=))'
    OP_LT = '<'
    OP_LTE = '<='
    OP_GT = '>'
    OP_GTE = '>='
    OP_LIKE = 'like'
    OP_NOT = 'not'
    OP_AND = 'and'
    OP_OR = 'or'
    space='regexp:\s+'
    number='regexp:\d+'
    idSimple="regexp:[a-zA-Zа-яА-Я][a-zA-Zа-яА-Я0123456789]*"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
    line_comment="regexp://.*"
  ]
}

grammar ::= sqlQuery

select_statement ::= !<<eof>> select topOpt distinctOpt selectList
fromKeyword tableDeclaration
joinItem*
[whereKeyword expression]
[groupByKeyword expressionList [havingKeyword expression]]{
    methods = [
        topCount = "topOpt/numberLiteral"
        topOpt = ""
        whereExpression = "expression[0]"
        havingExpression ="expression[1]"
        grouping = "expressionList"
        expressionList =""
        //todo. isDistinct
    ]
}

private fromKeyword ::= (from | из)
topOpt ::= [top numberLiteral] //TODO. trash.make private
private distinctOpt ::= distinct?
alias ::= as? identifier //TODO. trash.make private

//selection
selectionItem ::= expression alias? {
    methods = [
        identifier = ""
        alias = "alias/identifier"
    ]
}
selectionList ::= selectionItem (COMMA selectionItem)*{
    //TODO. isSelectAll
}

private selectList ::= (ASTERISK | selectionList ) {recoverWhile=notFromKeyword pin=1}
private notFromKeyword ::= !fromKeyword

//source
tableDeclaration ::= identifier alias?{
    methods = [
        alias = "alias/identifier"
        identifier = ""
        tableName = "identifier"
    ]
}
subquery ::= LPAREN sqlQuery RPAREN
subqueryTable::= subquery alias{
    methods = [
        subquery = "/subquery"
        alias = "alias/identifier"
    ]
}
columnSource::= tableDeclaration | subqueryTable

//optional clauses
private whereKeyword::= where | где
private groupByKeyword ::= (group by) | (сгруппировать по)
private havingKeyword ::= having | имеющие

//order by
private orderByKeyword::= (order by) | (упорядочить по)
private ascKeyword ::= asc | возр
private descKeyword::= desc | убыв
private orderDirectionOpt ::= [ascKeyword | descKeyword]
orderItem ::= expression orderDirectionOpt
private orderByExpressionList ::= orderItem (COMMA orderItem) *

//union
private unionKeyword ::= union| объединить
private allModifierOpt ::= [all | все]
private unionList ::= select_statement (unionKeyword allModifierOpt select_statement)*
sqlQuery::= unionList [orderByKeyword orderByExpressionList]

//join
private joinKeyword ::= join | соединение
private outerKeywordOpt ::= (outer | внешнее)?
private outerJoinKind::= full | left | right | полное | левое | правое
joinKind::= (inner | внутреннее) | (outerJoinKind outerKeywordOpt)

joinItem ::= joinKind? joinKeyword columnSource (on | по) expression

//identifiers
identifier ::= idSimple (DOT idSimple)*

stringLiteral ::= string
numberLiteral ::= number
boolLiteral ::= (true | false | истина | ложь)

expressionList ::=  expression (COMMA expression)*

expression ::=
//Priority increases from top to bottom
  boolean_group
  | unary_group
  | comparison_group
  | add_group
  | mul_group
  | primary_group

fake binaryExpression::= expression expression {
    methods = [
        left = "expression[0]"
        right = "expression[1]"
        expressionList = ""
    ]
}
fake unaryExpression ::= expression {
    methods = [
        operand = "expression"
        expressionList = ""
    ]
}

private add_group ::=  addExpr| subtractExpr
addExpr ::= expression '+' expression {elementType = binaryExpression}
subtractExpr ::= expression '-' expression {elementType = binaryExpression}

private mul_group ::= multExpr | divExpr | remExpr
multExpr ::= expression ASTERISK expression {elementType = binaryExpression}
divExpr ::= expression OP_DIV expression {elementType = binaryExpression}
remExpr ::= expression OP_REM expression {elementType = binaryExpression}

private unary_group ::= unaryNotExpr
unaryNotExpr ::= OP_NOT expression {elementType = unaryExpression}

private comparison_group ::= eqExpr
    | neqExpr
    | ltExpr
    | lteExpr
    | gtExpr
    | gteExpr
    | likeExpr

eqExpr ::= expression OP_EQ expression {elementType = binaryExpression}
neqExpr ::= expression OP_NEQ expression {elementType = binaryExpression}
ltExpr ::= expression OP_LT expression {elementType = binaryExpression}
lteExpr ::= expression OP_LTE expression {elementType = binaryExpression}
gtExpr ::= expression OP_GT expression {elementType = binaryExpression}
gteExpr ::= expression OP_GTE expression {elementType = binaryExpression}
likeExpr ::= expression OP_LIKE expression {elementType = binaryExpression}

private boolean_group ::= andExpr | orExpr
andExpr ::= expression OP_AND expression {elementType = binaryExpression}
orExpr ::= expression OP_OR expression {elementType = binaryExpression}

private primary_group ::=
    identifier
    | numberLiteral
    | boolLiteral
    | stringLiteral
    | parExpr
parExpr::= '(' expression ')' {elementType = expression}


